<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wings&#39; Blog</title>
  
  <subtitle>翻过这座山，他们就会听到你的故事。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Wsycat/"/>
  <updated>2019-04-11T12:52:28.528Z</updated>
  <id>https://github.com/Wsycat/</id>
  
  <author>
    <name>Whj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="https://github.com/Wsycat/2019/04/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://github.com/Wsycat/2019/04/11/动态规划/</id>
    <published>2019-04-11T01:19:04.000Z</published>
    <updated>2019-04-11T12:52:28.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h1><p><strong>动态规划</strong>（英语：Dynamic programming，简称DP）是一种在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">数学</a>、<a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E7%90%86%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">管理科学</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6" target="_blank" rel="noopener">经济学</a>和<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6" target="_blank" rel="noopener">生物信息学</a>中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92#cite_note-1" target="_blank" rel="noopener">[1]</a>和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">最优子结构</a>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<a href="https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96" target="_blank" rel="noopener">记忆化</a>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E5%A2%9E%E9%95%B7" target="_blank" rel="noopener">指数增长</a>时特别有用。</p><p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="LeetCode-887-鸡蛋掉落"><a href="#LeetCode-887-鸡蛋掉落" class="headerlink" title="LeetCode 887:鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">LeetCode 887:鸡蛋掉落</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1：</p><p>输入：K = 1, N = 2<br>输出：2<br>解释：</p><p>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>示例 2：</p><p>输入：K = 2, N = 6<br>输出：3<br>示例 3：</p><p>输入：K = 3, N = 14</p><p>输出：4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始我是没有明白题意的，直到我看到了这个解释才恍然大悟（有点二分查找的意思？）</p><p><img src="\img\抛鸡蛋问题.png" alt></p><p>诚然，我在学习的过程中因为学识浅薄总是会把几种相似的问题混杂在一起，因为从某种程度上来说，递推、贪心、搜索和动态规划有些相似的地方，因为它们的每一步都是有对应的状态的。而决定问题解决方式的根本是<strong>这些状态的转移方式</strong>。</p><p>每个阶段都只有一个状态——递推（e.g.斐波那契数列）</p><p>每个阶段最优解基于<strong>上个阶段的最优解</strong>——贪心算法。</p><p>每个阶段的最优状态由之前<strong>所有状态</strong>的组合得到——搜索。</p><p>每个状态的最优状态可以从之前<strong>某个阶段的某个或某些</strong>状态直接得到而不管之前这个状态是如何得到的——动态规划。</p><p>DP的通用解法思路为：</p><ol><li>设计状态，常见的是用一个DP数组来表示各阶段的状态。</li><li>找出状态之间的关系。</li><li>算法实现。</li></ol><p>首先，我们用二维数组DP[k][Step]来表示拥有K个鸡蛋移动Step次的情况下确定的最高楼层。</p><p><img src="\img\扔鸡蛋原理图.png" alt></p><p>所以我们的状态方程递推式为</p><p>DP[K][Step] = DP[K][Step-1]+DP[K-1][Step-1]+1</p><p>设置循环跳出条件为DP[K][Step]&lt;=N，最后返回相应的Step。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;     </span><br><span class="line"><span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;K+<span class="number">1</span>;i++)&#123;<span class="comment">//数组初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span> ; j&lt;N+<span class="number">1</span> ; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=K;i++) &#123;<span class="comment">//构建循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N;j++) &#123;</span><br><span class="line">dp[i][j] = dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>; <span class="comment">//状态方程</span></span><br><span class="line"><span class="keyword">if</span> (dp[K][j]&gt;=N) &#123;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若循环找不出结果返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="换硬币"><a href="#换硬币" class="headerlink" title="换硬币"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">换硬币</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p>你可以认为每种硬币的数量是无限的。</p><p>思路：</p><p>还是要找出递推式，这里很容易让人想用贪心算法，但是贪心算法在这种题目里容易被一些case算计，所以还是用动态规划好了。</p><p>首先用count[N]表示总价为N的最少换币数量。我们举个针对贪心算法的例子：coins[] = {1，5，11} amount = 15，贪心算法就会选择11×1+1×4 ，一共5张，而不是5×3的三张。这里我们可以想到</p><p>$$<br>count[15] = min（count[14],count[10],count[4]）+1<br>$$</p><p>所以，我们可以通过创建一个新的数组用来保存每一个acount的最少硬币个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//边界条件一定考虑</span></span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;=amount;i++)&#123;</span><br><span class="line">            ans[i] = Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;=amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> item : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - item &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    ans[i] = Math.min(ans[i],ans[i-item]+<span class="number">1</span>);</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[amount]!=Integer.MAX_VALUE-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans[amount]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li>什么是动态规划？动态规划的意义是什么？ - 王勐的回答 - 知乎<br><a href="https://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="noopener">https://www.zhihu.com/question/23995189/answer/35429905</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（英语：Dynamic programming，
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://github.com/Wsycat/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://github.com/Wsycat/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="https://github.com/Wsycat/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle调研</title>
    <link href="https://github.com/Wsycat/2019/04/10/Kaggle%E8%B0%83%E7%A0%94/"/>
    <id>https://github.com/Wsycat/2019/04/10/Kaggle调研/</id>
    <published>2019-04-10T11:06:39.000Z</published>
    <updated>2019-04-10T13:55:42.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kaggle简介"><a href="#Kaggle简介" class="headerlink" title="Kaggle简介"></a>Kaggle简介</h1><p><strong>Kaggle</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1" target="_blank" rel="noopener">数据建模</a>和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" target="_blank" rel="noopener">数据分析</a>竞赛平台。企业和研究者可在其上发布数据，统计学者和数据挖掘专家可在其上进行竞赛以产生最好的模型。这一<a href="https://zh.wikipedia.org/wiki/%E4%BC%97%E5%8C%85" target="_blank" rel="noopener">众包</a>模式依赖于这一事实，即有众多策略可以用于解决几乎所有预测建模的问题，而研究者不可能在一开始就了解什么方法对于特定问题是最为有效的。Kaggle的目标则是试图通过众包的形式来解决这一难题，进而使<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">数据科学</a>成为一场运动。2017年3月8日谷歌官方博客宣布收购Kaggle。</p><h1 id="Competitions"><a href="#Competitions" class="headerlink" title="Competitions"></a>Competitions</h1><h2 id="比赛类型"><a href="#比赛类型" class="headerlink" title="比赛类型"></a>比赛类型</h2><p>比赛类型按照参赛者分为公开赛General和为大学团体提供的Kaggle-in-Class项目。<img src="\img\kaggle比赛类型.png" alt="kaggle比赛类型"></p><p>比赛按照比赛标签分为：</p><ol><li><strong>Featured：</strong>是瞄准商业问题带有奖金的公开竞赛，竞争激烈，允许团队参赛和个人参赛（solo）。</li><li><strong>Research</strong>：竞赛通常是机器学习前沿技术或者公益性质的题目。竞赛奖励可能是现金，也有一部分以会议邀请、发表论文的形式奖励。</li><li><strong>Recruitment</strong>：赞助企业寻求数据科学家、算法设计人才的渠道。只允许个人参赛，不接受团队报名。</li><li><strong>Getting start</strong>：相当于新手村，由三个经典的竞赛题来进行入门教学。三道题分别是<a href="https://www.kaggle.com/c/digit-recognizer" target="_blank" rel="noopener">手写数字识别</a>、<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">泰坦尼克</a>、<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" target="_blank" rel="noopener">房价预测</a>。</li><li><strong>Master</strong>：大师邀请赛。</li><li><strong>Playground</strong>：游乐场。</li></ol><h1 id="竞赛流程"><a href="#竞赛流程" class="headerlink" title="竞赛流程"></a>竞赛流程</h1><p>选一个题目&gt;&gt;下载数据&gt;&gt;训练模型&gt;&gt;提交结果&gt;&gt;查看排名&gt;&gt;优化模型（迭代）&gt;&gt;最终提交&gt;&gt;比赛结束。</p><h1 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h1><p>竞赛题目上指向的数据库和这个Datasets指向的是同一个地方，这里可以下载到提交结果的示范、测试集、训练集。Kaggle的数据常用csv格式，提交结果也为csv格式。</p><p><img src="\img\kaggle比赛类型.png" alt></p><h1 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h1><p>英文直译为核心，内核。这里是Kaggle其他参赛者自愿公开代码互相学习的地方。这一办款同样支持在线运行和调试代码，目前支持Python、R，同样支持诸如numpy、pandas之类的数据分析库。</p><p><img src="\img\kagglekernels.png" alt></p><p>这里可以通过对编程语言和标签等进行选择。当你想要学习别人是如何清洗数据的时候，标签选择data cleaning会给你带来便利。</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>Kaggle讨论区以及网站论坛：</p><p><img src="\img\kagglediscussion.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kaggle简介&quot;&gt;&lt;a href=&quot;#Kaggle简介&quot; class=&quot;headerlink&quot; title=&quot;Kaggle简介&quot;&gt;&lt;/a&gt;Kaggle简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Kaggle&lt;/strong&gt;是一个&lt;a href=&quot;https://zh.
      
    
    </summary>
    
      <category term="Kaggle" scheme="https://github.com/Wsycat/categories/Kaggle/"/>
    
    
      <category term="Kaggle" scheme="https://github.com/Wsycat/tags/Kaggle/"/>
    
      <category term="调研" scheme="https://github.com/Wsycat/tags/%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
</feed>
