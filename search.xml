<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[目标检测]]></title>
    <url>%2F2019%2F04%2F26%2F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[前言目标检测是计算机视觉领域内一个长期存在的基础性难题，几十年来也一直都是一个活跃的研究领域。目标检测的目标是确定某张给定图像中是否存在给定类别（比如人、车、自行车、狗和猫）的目标实例；如果存在，就返回每个目标实例的空间位置和覆盖范围。作为图像理解和计算机视觉的基石，目标检测是解决分割、场景理解、目标追踪、图像描述、事件检测和活动识别等更复杂更高层次的视觉任务的基础。目标检测在人工智能和信息技术的许多领域都有广泛的应用，包括机器人视觉、消费电子产品、安保、自动驾驶、人机交互、基于内容的图像检索、智能视频监控和增强现实。 目标检测常见算法目标检测实现的一般思路目标检测要实现的无非于解决目标是什么、目标在哪儿这两个问题。目前学术和工业界出现的目标检测算法分成3类： 传统的目标检测算法：Cascade + HOG/DPM + Haar/SVM以及上述方法的诸多改进、优化； 候选区域/窗 + 深度学习分类：通过提取候选区域，并对相应区域进行以深度学习方法为主的分类的方案，如： R-CNN（Selective Search + CNN + SVM） SPP-net（ROI Pooling） Fast R-CNN（Selective Search + CNN + ROI） Faster R-CNN（RPN + CNN + ROI） R-FCN 基于深度学习的回归方法：YOLO/SSD/DenseBox 等方法；以及最近出现的结合RNN算法的RRC detection；结合DPM的Deformable CNN等。 其中2属于 2-stage模型，3属于1-stage模型，类型区别主要取决于它实现步骤上的区别，2类别是选框与分类两步走，3类别是对预测的目标物体进行回归。本文主要围绕2类型的检测算法进行介绍。 R-CNNR-CNN的简要步骤(1) 输入测试图像(2) 利用选择性搜索Selective Search算法在图像中从下到上提取2000个左右的可能包含物体的候选区域Region Proposal(3) 因为取出的区域大小各自不同，所以需要将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN，将CNN的fc7层的输出作为特征(4) 将每个Region Proposal提取到的CNN特征输入到SVM进行分类 存在问题及改进方式问题1：通过selective search提取2000个候选框之后要对每一个框进行特征提取并进行svm分类，计算量相当大，导致检测速度变得异常慢。 解决方式：先对整个图像进行一次特征提取，然后只需要region proposal在原图的位置映射到卷积特征图上，这样对于一张图像我们只需要提取一次特征就好了。 问题2：全连接层的输入是固定长度，这时候就需要对图片进行resize操作，会导致失真。 解决方式：Spatial Pyramid Pooling（空间金字塔池化），在全连接层之前接入一个SPP结构，然后将之输入到全连接层进行分类。]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
        <tag>R-CNN</tag>
        <tag>Fast R-CNN</tag>
        <tag>Faster R-CNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。 实例LeetCode 887:鸡蛋掉落题目描述你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例示例 1： 输入：K = 1, N = 2输出：2解释： 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。示例 2： 输入：K = 2, N = 6输出：3示例 3： 输入：K = 3, N = 14 输出：4 思路一开始我是没有明白题意的，直到我看到了这个解释才恍然大悟（有点二分查找的意思？） 诚然，我在学习的过程中因为学识浅薄总是会把几种相似的问题混杂在一起，因为从某种程度上来说，递推、贪心、搜索和动态规划有些相似的地方，因为它们的每一步都是有对应的状态的。而决定问题解决方式的根本是这些状态的转移方式。 每个阶段都只有一个状态——递推（e.g.斐波那契数列） 每个阶段最优解基于上个阶段的最优解——贪心算法。 每个阶段的最优状态由之前所有状态的组合得到——搜索。 每个状态的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的——动态规划。 DP的通用解法思路为： 设计状态，常见的是用一个DP数组来表示各阶段的状态。 找出状态之间的关系。 算法实现。 首先，我们用二维数组DP[k][Step]来表示拥有K个鸡蛋移动Step次的情况下确定的最高楼层。 所以我们的状态方程递推式为 DP[K][Step] = DP[K][Step-1]+DP[K-1][Step-1]+1 设置循环跳出条件为DP[K][Step]&lt;=N，最后返回相应的Step。 123456789101112131415161718192021class Solution &#123; public int superEggDrop(int K, int N) &#123; int [][]dp = new int[K+1][N+1]; for(int i = 0 ; i&lt;K+1;i++)&#123;//数组初始化 for(int j =0 ; j&lt;N+1 ; j++)&#123; dp[i][j] = 0; &#125; &#125; for(int i = 1; i &lt;=K;i++) &#123;//构建循环 for(int j = 1; j &lt;= N;j++) &#123; dp[i][j] = dp[i][j-1]+dp[i-1][j-1]+1; //状态方程 if (dp[K][j]&gt;=N) &#123; return j; &#125; &#125; &#125; return 0;//若循环找不出结果返回0 &#125;&#125; 换硬币题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 你可以认为每种硬币的数量是无限的。 思路： 还是要找出递推式，这里很容易让人想用贪心算法，但是贪心算法在这种题目里容易被一些case算计，所以还是用动态规划好了。 首先用count[N]表示总价为N的最少换币数量。我们举个针对贪心算法的例子：coins[] = {1，5，11} amount = 15，贪心算法就会选择11×1+1×4 ，一共5张，而不是5×3的三张。这里我们可以想到 $$count[15] = min（count[14],count[10],count[4]）+1$$ 所以，我们可以通过创建一个新的数组用来保存每一个acount的最少硬币个数。 123456789101112131415161718192021222324import java.lang.Math;class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(amount==0) return 0; //边界条件一定考虑 int []ans = new int[amount+1]; for(int i =0 ;i&lt;=amount;i++)&#123; ans[i] = Integer.MAX_VALUE-1; &#125; ans[0] = 0; for(int i =1 ; i&lt;=amount;i++)&#123; for(int item : coins)&#123; if(i - item &gt;=0)&#123; ans[i] = Math.min(ans[i],ans[i-item]+1); &#125; &#125; &#125; if(ans[amount]!=Integer.MAX_VALUE-1)&#123; return ans[amount]; &#125; else return -1; &#125;&#125; 参考链接 什么是动态规划？动态规划的意义是什么？ - 王勐的回答 - 知乎https://www.zhihu.com/question/23995189/answer/35429905]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaggle调研]]></title>
    <url>%2F2019%2F04%2F10%2FKaggle%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[Kaggle简介Kaggle是一个数据建模和数据分析竞赛平台。企业和研究者可在其上发布数据，统计学者和数据挖掘专家可在其上进行竞赛以产生最好的模型。这一众包模式依赖于这一事实，即有众多策略可以用于解决几乎所有预测建模的问题，而研究者不可能在一开始就了解什么方法对于特定问题是最为有效的。Kaggle的目标则是试图通过众包的形式来解决这一难题，进而使数据科学成为一场运动。2017年3月8日谷歌官方博客宣布收购Kaggle。 Competitions比赛类型比赛类型按照参赛者分为公开赛General和为大学团体提供的Kaggle-in-Class项目。 比赛按照比赛标签分为： Featured：是瞄准商业问题带有奖金的公开竞赛，竞争激烈，允许团队参赛和个人参赛（solo）。 Research：竞赛通常是机器学习前沿技术或者公益性质的题目。竞赛奖励可能是现金，也有一部分以会议邀请、发表论文的形式奖励。 Recruitment：赞助企业寻求数据科学家、算法设计人才的渠道。只允许个人参赛，不接受团队报名。 Getting start：相当于新手村，由三个经典的竞赛题来进行入门教学。三道题分别是手写数字识别、泰坦尼克、房价预测。 Master：大师邀请赛。 Playground：游乐场。 竞赛流程选一个题目&gt;&gt;下载数据&gt;&gt;训练模型&gt;&gt;提交结果&gt;&gt;查看排名&gt;&gt;优化模型（迭代）&gt;&gt;最终提交&gt;&gt;比赛结束。 Datasets竞赛题目上指向的数据库和这个Datasets指向的是同一个地方，这里可以下载到提交结果的示范、测试集、训练集。Kaggle的数据常用csv格式，提交结果也为csv格式。 Kernels英文直译为核心，内核。这里是Kaggle其他参赛者自愿公开代码互相学习的地方。这一办款同样支持在线运行和调试代码，目前支持Python、R，同样支持诸如numpy、pandas之类的数据分析库。 这里可以通过对编程语言和标签等进行选择。当你想要学习别人是如何清洗数据的时候，标签选择data cleaning会给你带来便利。 DiscussionKaggle讨论区以及网站论坛：]]></content>
      <categories>
        <category>Kaggle</category>
      </categories>
      <tags>
        <tag>Kaggle</tag>
        <tag>调研</tag>
      </tags>
  </entry>
</search>
